// Token Metadata Enrichment Service
// –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ API –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤

const fetch = require('node-fetch');
const axios = require('axios');

// –ö–µ—à –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
const tokenMetadataCache = new Map();

// Jupiter Token List –¥–ª—è –æ—Å–Ω–æ–≤–Ω—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤ Solana
const JUPITER_TOKEN_LIST = 'https://token.jup.ag/strict';

// DexScreener API –¥–ª—è Pump.fun –∏ –¥—Ä—É–≥–∏—Ö —Ç–æ–∫–µ–Ω–æ–≤
const DEXSCREENER_API = 'https://api.dexscreener.com/latest/dex/tokens';

// –ö–µ—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ —Ç–æ–∫–µ–Ω–æ–≤ Jupiter
let jupiterTokens = null;

/**
 * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è - –∑–∞–≥—Ä—É–∑–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤ –∏–∑ Jupiter
 */
async function initializeTokenMetadata() {
    try {
        console.log('ü™ô Loading Jupiter token list...');
        const response = await fetch(JUPITER_TOKEN_LIST);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        jupiterTokens = await response.json();
        
        if (!Array.isArray(jupiterTokens)) {
            throw new Error('Invalid token list format received');
        }
        
        console.log(`‚úÖ Loaded ${jupiterTokens.length} token metadata records`);
        return true;
    } catch (error) {
        console.error('‚ùå Failed to load Jupiter token list:', error.message);
        jupiterTokens = [];
        console.log('üîÑ Token metadata service will work with empty list (fallback to address-only mode)');
        return false;
    }
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω–∞ –∏–∑ DexScreener (–¥–ª—è Pump.fun –∏ –º–æ–ª–æ–¥—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤)
 * @param {string} tokenMint 
 * @returns {Promise<Object|null>}
 */
async function fetchFromDexScreener(tokenMint) {
    try {
        const response = await axios.get(`${DEXSCREENER_API}/${tokenMint}`, {
            timeout: 5000
        });
        
        if (response.data && response.data.pairs && response.data.pairs.length > 0) {
            const pair = response.data.pairs[0];
            const token = pair.baseToken;
            
            return {
                address: token.address,
                name: token.name || 'Unknown Token',
                symbol: token.symbol || tokenMint.slice(0, 4).toUpperCase(),
                image: pair.info?.imageUrl || '/img/token-placeholder.png',
                decimals: 6,
                price: parseFloat(pair.priceUsd) || 0,
                priceChange: pair.priceChange?.h24 || 0,
                market_cap: parseFloat(pair.fdv) || 0,
                liquidity: parseFloat(pair.liquidity?.usd) || 0,
                volume24h: parseFloat(pair.volume?.h24) || 0,
                verified: false,
                source: 'dexscreener'
            };
        }
        
        return null;
    } catch (error) {
        // –ù–µ –ª–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É - —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ –µ—Å–ª–∏ —Ç–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω
        return null;
    }
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω–∞ –ø–æ –∞–¥—Ä–µ—Å—É (—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è –∫–µ—à–∞)
 * @param {string} tokenMint - –ê–¥—Ä–µ—Å —Ç–æ–∫–µ–Ω–∞ –Ω–∞ Solana
 * @returns {Object} Metadata –æ–±—ä–µ–∫—Ç
 */
function getTokenMetadata(tokenMint) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–µ—à
    if (tokenMetadataCache.has(tokenMint)) {
        return tokenMetadataCache.get(tokenMint);
    }

    // –ò—â–µ–º –≤ Jupiter Token List
    const token = jupiterTokens?.find(t => t.address === tokenMint);
    
    let metadata = {
        address: tokenMint,
        name: 'Unknown Token',
        symbol: tokenMint.slice(0, 4).toUpperCase() + '...',
        image: '/img/token-placeholder.png',
        decimals: 6,
        price: 0,
        priceChange: 0,
        market_cap: 0,
        source: 'fallback'
    };

    if (token) {
        metadata = {
            address: token.address,
            name: token.name || token.symbol || 'Unknown Token',
            symbol: token.symbol || tokenMint.slice(0, 4).toUpperCase(),
            image: token.logoURI || '/img/token-placeholder.png',
            decimals: token.decimals || 6,
            price: 0,
            priceChange: 0,
            market_cap: 0,
            tags: token.tags || [],
            verified: token.verified || false,
            source: 'jupiter'
        };
    }

    // –ö–µ—à–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    tokenMetadataCache.set(tokenMint, metadata);
    return metadata;
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω–∞ (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å DexScreener)
 * @param {string} tokenMint 
 * @returns {Promise<Object>}
 */
async function getTokenMetadataAsync(tokenMint) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–µ—à
    if (tokenMetadataCache.has(tokenMint)) {
        const cached = tokenMetadataCache.get(tokenMint);
        // –ï—Å–ª–∏ —ç—Ç–æ fallback - –ø—ã—Ç–∞–µ–º—Å—è –æ–±–Ω–æ–≤–∏—Ç—å –∏–∑ DexScreener
        if (cached.source !== 'fallback') {
            return cached;
        }
    }

    // –°–Ω–∞—á–∞–ª–∞ –ø—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –∏–∑ DexScreener (–º–æ–ª–æ–¥—ã–µ —Ç–æ–∫–µ–Ω—ã, Pump.fun)
    const dexData = await fetchFromDexScreener(tokenMint);
    if (dexData) {
        tokenMetadataCache.set(tokenMint, dexData);
        return dexData;
    }

    // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ - –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–∏–Ω—Ö—Ä–æ–Ω–Ω—É—é –≤–µ—Ä—Å–∏—é (Jupiter + fallback)
    return getTokenMetadata(tokenMint);
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Ü–µ–Ω—ã —Ç–æ–∫–µ–Ω–∞ —á–µ—Ä–µ–∑ Jupiter API
 * @param {string} tokenMint - –ê–¥—Ä–µ—Å —Ç–æ–∫–µ–Ω–∞
 * @returns {Promise<number>} –¶–µ–Ω–∞ –≤ USD
 */
async function getTokenPrice(tokenMint) {
    try {
        const response = await fetch(`https://price.jup.ag/v4/price?ids=${tokenMint}`);
        const data = await response.json();
        return data.data?.[tokenMint]?.price || 0;
    } catch (error) {
        console.error(`‚ùå Failed to get price for ${tokenMint}:`, error);
        return 0;
    }
}

/**
 * –û–±–æ–≥–∞—â–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏ —Ç–æ–∫–µ–Ω–æ–≤
 * @param {Array} transactions - –ú–∞—Å—Å–∏–≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
 * @returns {Promise<Array>} –û–±–æ–≥–∞—â–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
 */
async function enrichTransactionData(transactions) {
    if (!transactions || !Array.isArray(transactions)) {
        return transactions;
    }

    const enrichedData = await Promise.all(
        transactions.map(async (tx) => {
            const tokenMetadata = getTokenMetadata(tx.token_mint);
            
            // –ü–æ–ª—É—á–∞–µ–º —Ü–µ–Ω—É —Ç–æ–∫–µ–Ω–∞ –µ—Å–ª–∏ –Ω—É–∂–Ω–∞ —Å—Ç–æ–∏–º–æ—Å—Ç—å
            let tokenPrice = 0;
            if (tx.needs_price_lookup) {
                tokenPrice = await getTokenPrice(tx.token_mint);
            }

            return {
                ...tx,
                token_name: tokenMetadata.name,
                token_symbol: tokenMetadata.symbol,
                token_image: tokenMetadata.image,
                token_decimals: tokenMetadata.decimals,
                token_price: tokenPrice,
                token_verified: tokenMetadata.verified || false
            };
        })
    );

    return enrichedData;
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–∏–º–≤–æ–ª–∞ —Ç–æ–∫–µ–Ω–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
 * @param {string} tokenMint 
 * @returns {string} –°–∏–º–≤–æ–ª —Ç–æ–∫–µ–Ω–∞
 */
function getTokenSymbol(tokenMint) {
    const metadata = getTokenMetadata(tokenMint);
    return metadata.symbol;
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–º–µ–Ω–∏ —Ç–æ–∫–µ–Ω–∞
 * @param {string} tokenMint 
 * @returns {string} –ò–º—è —Ç–æ–∫–µ–Ω–∞
 */
function getTokenName(tokenMint) {
    const metadata = getTokenMetadata(tokenMint);
    return metadata.name;
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ URL –∞–≤–∞—Ç–∞—Ä–∫–∏ —Ç–æ–∫–µ–Ω–∞
 * @param {string} tokenMint 
 * @returns {string} URL –∞–≤–∞—Ç–∞—Ä–∫–∏
 */
function getTokenImage(tokenMint) {
    const metadata = getTokenMetadata(tokenMint);
    return metadata.image;
}

/**
 * –ú–∞—Å—Å–æ–≤–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–ø–∏—Å–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤
 * @param {Array<string>} tokenMints 
 * @returns {Promise<Map>}
 */
async function fetchMultipleTokenMetadata(tokenMints) {
    const uniqueTokens = [...new Set(tokenMints)];
    const results = new Map();
    
    // –ü–æ–ª—É—á–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ (–±–∞—Ç—á–∞–º–∏ –ø–æ 10)
    const batchSize = 10;
    for (let i = 0; i < uniqueTokens.length; i += batchSize) {
        const batch = uniqueTokens.slice(i, i + batchSize);
        const batchResults = await Promise.all(
            batch.map(async (mint) => {
                const metadata = await getTokenMetadataAsync(mint);
                return [mint, metadata];
            })
        );
        batchResults.forEach(([mint, metadata]) => results.set(mint, metadata));
    }
    
    return results;
}

module.exports = {
    initializeTokenMetadata,
    getTokenMetadata,
    getTokenMetadataAsync,
    getTokenPrice,
    enrichTransactionData,
    getTokenSymbol,
    getTokenName,
    getTokenImage,
    fetchMultipleTokenMetadata,
    fetchFromDexScreener
};
